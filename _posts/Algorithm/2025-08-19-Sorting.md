---
title: 알고리즘 공부) 정렬
date: 2025-08-19 21:42:00 +0900
categories: ['Algorithm']
tags: ['Algorithm', 'Sort', '알고리즘', '정렬']
math: true
---

> 개인적으로 공부한 내용을 정리하여 작성하였기 때문에 잘못된 정보가 포함되어 있을 수 있습니다.
{: .prompt-warning }

## 정렬
정렬<sup style="color:gray">Sorting</sup>은 데이터(원소들)를 특정 규칙에 따라 순서대로 재배치하는 과정입니다. 예를 들어, 숫자 목록을 작은 수부터 큰 수로 배열하거나, 사람들의 이름을 가나다순으로 정리하는 게 바로 정렬에 속합니다. 책장 속 책들을 제목순으로 꽂는 것처럼 말이죠. 이러한 정렬 규칙은 숫자 크기, 알파벳 순서, 나이 또는 사용자가 직접 정한 기준(가격순 등)이 될 수 있습니다.

정렬의 가장 큰 목적은 데이터를 더 쉽게 다루고, 빠르게 찾거나 처리할 수 있게하는 것입니다. 정렬되지 않은 데이터는 마치 어질러진 여러분들의 방처럼 원하는 걸 찾기 힘듭니다. 잘 정렬된 데이터는 다음과 같은 이점을 갖습니다.

- **빠른 검색**: 1,000개의 숫자 목록에서 특정 숫자를 찾을 때, 정렬되어 있지 않으면 하나씩 다 확인해봐야 합니다. 하지만, 정렬되어 있으면 이진 탐색 등을 통해 로그 시간에 가까운 탐색이 가능해집니다.
- **쉬운 처리**: 장바구니 목록에서 중복된 물품을 제거하거나(중복 항목 제거), 설문 조사에서 가장 많은 답변을 찾는 것처럼(빈도 세기) 다양한 연산의 작업 수행이 쉬워집니다.

### 정렬의 장점과 단점
#### 장점
온라인 쇼핑몰에서 상품을 가격순으로 정렬하면 고객이 원하는 물품을 쉽게 선택할 수 있는 것처럼 데이터가 예쁘고 접근하기 쉬워집니다. 또한, 후속 작업(탐색, 분석 등)의 수행이 빨라져 시간과 비용을 절약할 수 있습니다.

#### 단점
정렬은 데이터의 크기가 매우 크거나, 잘못된 알고리즘을 선택하면 시간이 매우 오래걸리고, 추가 메모리(공간)가 필요할 수 있습니다. 어쩌면 죽을 때까지 안 끝날 지도 모릅니다.

### 정렬의 분류
정렬 알고리즘은 데이터를 어떻게 처리하고 순서를 결정하는 지에 따라 여러 기준으로 분류할 수 있지만, 크게 비교 기반과 비비교 기반으로 분류해볼 수 있습니다. 이러한 분류는 <u class="wavy">원소 간의 관계를 파악</u>하는 방식에 초점을 맞추고 있습니다. 각 분류의 원리와 장단점 그리고 대표적인 알고리즘에 대해 알아봅시다.

#### 비교 기반 정렬(Comparison-Based Sorting)
이 유형의 알고리즘은 원소들을 서로 **비교 연산**하여 순서를 결정합니다. *A가 B보다 큰가요?*{: style="color:brown" } 와 같이 물어보며 정렬하죠. 모든 종류의 데이터(숫자, 문자열 등)에 적용 가능하지만, 최악의 경우 최소 $O(n log n)$번의 비교가 필요하다는 이론적 한계가 존재합니다.

데이터가 비교 가능하기만 하면 정렬이 가능하기 때문에 범용성이 높고, 대부분의 많은 라이브러리에서 제공 및 사용 중이기도 합니다. 다만, 비교 횟수가 많아 큰 데이터에서 사용할 시 느리다는 단점이 있습니다.

대표적인 알고리즘으로 삽입 정렬과 버블 정렬, 선택 정렬, 병합 정렬, 퀵 정렬, 힙 정렬, 쉘 정렬 등이 있습니다.

#### 비비교 기반 정렬(Non-Comparison-Based Sorting)
이 유형의 알고리즘은 비교 대신 키의 구조나 분포를 활용합니다. 예를 들어, 숫자라면 자릿수나 범위를 이용하죠. 특정 조건에선 선형 시간($O(n)$)까지 가능하지만, 범용성이 다소 낮습니다.

대규모의 데이터를 다룰 때 유리하지만, 키의 제한과 추가적인 메모리 공간을 필요로 할 수 있습니다.

대표적인 알고리즘으로 카운팅 정렬과 기수 정렬, 버킷 정렬 등이 있습니다.

#### 추가적인 분류 기준
##### 안정성(Stability)
동일한 키 값을 가진 원소들 사이의 상대적 순서를 정렬 후에도 유지하는 성질입니다. 예를 들어, 두 사람의 나이가 같을 때 원래 순서를 그대로 지키는 지 여부입니다.

이 성질은 다중 키 정렬(예: 나이순 정렬 후 이름순으로 추가 정렬 시)에서 유용합니다. 안정적이지 않으면 이전의 정렬 결과가 깨질 수 있기 때문입니다.

삽입 정렬과 병합 정렬, 카운팅 정렬, 기수 정렬 등은 안정적인 알고리즘에 속하고, 선택 정렬과 퀵 정렬, 힙 정렬, 쉘 정렬 등은 불안정적인 알고리즘에 속합니다.
##### 제자리(In-Place)
추가적인 메모리 공간을 거의 사용하지 않고, 원본 배열 내에서만 정렬을 수행하는 지 여부입니다.

메모리의 사용이 제한된 환경(임베디드 등)에서 유용하지만, 안정성을 포기해야 하거나 구현이 복잡해질 수 있습니다.

삽입 정렬과 선택 정렬, 버블 정렬, 힙 정렬, 쉘 정렬 등이 제자리 알고리즘에 속하고, 병합 정렬과 카운팅 정렬 등이 비제자리 알고리즘에 속합니다.
##### 적응성(Adaptivity)
입력된 데이터가 이미 부분적으로 또는 완전히 정렬된 상태일 때, 알고리즘이 더 빠르게 동작하는 상황입니다.

일부 데이터는 어느 정도 정렬이 되어 있는 경우가 있으므로(로그 데이터 등), 불필요한 연산이 줄어 효율적으로 변합니다.

삽입 정렬과 버블 정렬 등이 적응성이 있고, 병합 정렬과 퀵 정렬, 선택 정렬 등은 비적응성인 편입니다.

## 마무리

정렬은 데이터 처리와 알고리즘 설계에 있어 가장 기본적이고도 핵심적인 작업입니다. 어떤 정렬 알고리즘을 사용할 지는 데이터의 크기와 분포, 메모리 제약, 속도(성능) 등 다각적인 요인을 고려하여 결정해야 합니다.