---
title: C++ 알고리즘) 서론
date: 2025-12-01 22:28:00 +0900
categories: ['Algorithm']
tags: ['Algorithm', 'Math', '알고리즘', '수학' ]
math: true
---

> 개인적으로 공부한 내용을 복습 겸 강좌 형식으로 작성한 글입니다. 잘못된 정보, 오타 등이 포함되어 있을 수 있습니다.
{: .prompt-warning }

## 알고리즘이란?
알고리즘<sup style="color:gray">Algorithm</sup>이라는 단어 많이 들어보셨죠?

<span class="focus-font" style="color:red">알 수 없는 알고리즘이 나를 여기로 이끌었다..., 내 알고리즘에 왜 나타나는거냐?</span>

이처럼 일상에서 자연스럽게 사용하지만, 막상 **알고리즘이 무엇인지** 명확히 설명하는 건 쉽지 않습니다. (쉽지 않음)

특히 IT 분야가 아닌 곳에선 _유튜브 추천 시스템 = 알고리즘_ 정도로 좁혀서 이해하는 경우도 있는 것 같습니다.

그거 아시나요? 알고리즘은 사실 그렇게 <span class="annotation" data-tooltip="어렵고 복잡하게 느껴지지만, 본질은 단순합니다.">거창한 개념</span>은 아닙니다. 알고리즘이란 <mark class="dynamic-highlight">어떤 문제를 해결하기 위해 따라야 하는 절차와 방법을 의미</mark>합니다. 즉, 컴퓨터, 과학, 수학 등 복잡한 분야의 전문가가 아니더라도 우리 모두는 알게 모르게 매일 알고리즘을 사용하고 있습니다.

예를 들어,

- **라면을 끓이는 순서**
- **서울역까지 가장 빠른 경로를 선택하는 판단**
- **정리정돈할 때 물건을 분류하는 방법**

이 모든 것이 알고리즘이라 볼 수 있습니다.

'너무 기술적이고 복잡한 것'이 아니라, '문제를 해결하기 위한 체계적인 단계'라고 생각하면 훨씬 친숙하게 다가올 겁니다.

----------

## 1부터 N까지 더하기

알고리즘을 조금 더 가볍게 이해하기 위해 예시 문제 하나로 시작해 봅시다. 바로, **1부터 50까지의 합 구하기**입니다. 시작부터 ㅈ같아서 뒤로 가기하고 싶겠지만 인내심을 갖고 읽어봅시다.

### 단순 반복으로 더하기

1부터 50까지의 합을 구하는 데 가장 떠오르는 방법은 1부터 50까지 하나씩 더하는 것입니다. 아래의 표와 같이 중간 과정을 적어가며 누적합을 구할 수도 있죠.

| 과정       | 합    | 과정        | 합     |
| :--------- | :---- | :---------- | :----- |
| $1 + 2$    | $3$   | $325 + 26$  | $351$  |
| $3 + 3$    | $6$   | $351 + 27$  | $378$  |
| $6 + 4$    | $10$  | $378 + 28$  | $406$  |
| $10 + 5$   | $15$  | $406 + 29$  | $435$  |
| $15 + 6$   | $21$  | $435 + 30$  | $465$  |
| $21 + 7$   | $28$  | $465 + 31$  | $496$  |
| $28 + 8$   | $36$  | $496 + 32$  | $528$  |
| $36 + 9$   | $45$  | $528 + 33$  | $561$  |
| $45 + 10$  | $55$  | $561 + 34$  | $595$  |
| $55 + 11$  | $66$  | $595 + 35$  | $630$  |
| $66 + 12$  | $78$  | $630 + 36$  | $666$  |
| $78 + 13$  | $91$  | $666 + 37$  | $703$  |
| $91 + 14$  | $105$ | $703 + 38$  | $741$  |
| $105 + 15$ | $120$ | $741 + 39$  | $780$  |
| $120 + 16$ | $136$ | $780 + 40$  | $820$  |
| $136 + 17$ | $153$ | $820 + 41$  | $861$  |
| $153 + 18$ | $171$ | $861 + 42$  | $903$  |
| $171 + 19$ | $190$ | $903 + 43$  | $946$  |
| $190 + 20$ | $210$ | $946 + 44$  | $990$  |
| $210 + 21$ | $231$ | $990 + 45$  | $1035$ |
| $231 + 22$ | $253$ | $1035 + 46$ | $1081$ |
| $253 + 23$ | $276$ | $1081 + 47$ | $1128$ |
| $276 + 24$ | $300$ | $1128 + 48$ | $1176$ |
| $300 + 25$ | $325$ | $1176 + 49$ | $1225$ |
|            |       | $1225 + 50$ | $1275$ |

정확한 답을 얻을 수 있는 확신의 알고리즘이지만, **연산 횟수는 49번**으로, 계산기로도 귀찮고 손으로 하면 손이 망가져 버립니다.(?)

이 방식은 **정확하지만 비효율적인 알고리즘**입니다.

### 가우스 덧셈 - 한 번에 계산

1부터 N까지의 합을 구하는 더 효율적인 방법이 있을까요?

1부터 50까지의 수를 잘 살펴보세요. 무언 가 규칙을 발견할 수 있습니다. 아니, 발견하지 못하더라도 괜찮습니다.

- $1 + 50 = 51$,
- $2 + 49 = 51$,
- $3 + 48 = 51$,
- ...

위와 같은 형식의 쌍이 총 25개로, 전체 합은 $51 \times 25 = 1275$로, 빠르게 답을 구해낼 수 있습니다.

이 방식을 흔히 가우스 덧셈<sup style="color:gray">Gauss Sum</sup>이라 부릅니다. 가우스가 초등학생 시절 선생님이 "1부터 100까지 더해오셈"이라고 하자, 정렬되어 있는 수의 규칙을 이용해 즉시 답(5,050)을 구했다고 전해지는 유명한 일화죠.

공식으로 나타내면 $S = \frac{n(n+1)}{2}$ 입니다.

이 단순한 공식 하나만으로, $O(N)$ 시간이 걸리던 계산이, $O(1)$로 줄어듭니다.

문제를 관찰하고 패턴을 찾아 더 효율적인 알고리즘을 설계한 대표적인 예시라 할 수 있습니다.

## 마무리

알고리즘은 단순한 계산을 넘어, 세상에 존재하는 크고 작은 문제들을 해결하기 위한 핵심적인 도구입니다.

하지만, 아무 알고리즘이나 사용할 순 없다는 것입니다. 같은 문제라도 어떤 알고리즘은 더럽게 느리고 비효율적일 수 있고, 어떤 알고리즘은 직관적이면서 겁나게 빠를 수 있습니다.

오글거리지만,,, 프로그래밍에서 알고리즘을 공부한다는 건 **더 나은 해결책을 고민하고 선택하는 능력**을 기르는 과정이라 할 수 있습니다.

앞으로 이어질 글에선 기초적인 알고리즘 원리를 C++과 함께합니다.

## 추천 문제
### [⚔️ 백준 8393번 - 합](https://www.acmicpc.net/problem/8393 "백준 8393번 - 합")
1부터 N까지의 합계를 구하는 문제로, 우리가 배운 내용으로 쉽게 해결할 수 있기 때문에 별도의 답안 및 해설은 없습니다.