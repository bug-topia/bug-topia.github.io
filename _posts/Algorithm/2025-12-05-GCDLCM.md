---
title: C++ 알고리즘) 최대공약수와 최소공배수
date: 2025-12-05 19:58:00 +0900
categories: ['Algorithm']
tags: ['Algorithm', 'GCD', 'LCM', 'Euclidean', '최대공약수', '최소공배수', '유클리드 호제법' ]
math: true
---

> 개인적으로 공부한 내용을 복습 겸 강좌 형식으로 작성한 글입니다. 잘못된 정보, 오타 등이 포함되어 있을 수 있습니다.
{: .prompt-warning }

## 서론

최솟값과 최댓값, 최빈값... 지금까지는 숫자들을 나열한 후 그 안에서 대장과 졸개를(?) 뽑는 느낌이었습니다.

오늘 배울 내용은 **두 숫자 간의 관계를 따져보는** 문제입니다. 맞습니다. 제목에 써있듯 오늘 배울 개념은 최대공약수와 최소공배수입니다.

제 기억이 맞다면 이 개념은 초등학교 5~6학년 때 배웁니다. 그만큼 오래되어서 잊었을 수 있으니, 아래에서 간단히 정의하겠습니다.

- **최대공약수<sup style="color:gray">Greatest Common Divisor, GCD</sup>**: 두 개 이상의 수에서 공통으로 나눌 수 있는 가장 큰 수
- **최소공배수<sup style="color:gray">Least Common Multiple, LCM</sup>**: 두 개 이상의 수의 배수 중 공통되는 가장 작은 수

개념 정의로만 보면 생각보다 간단합니다만, 알고리즘으로 구현하려면 생각보다 어렵습니다.

그리고 이 개념이 왜 코딩에서 중요할까요?

`"가로 120cm, 세로 80cm인 바닥에 남는 공간 없이 가장 큰 정사각형 타일로 채우려면?"`, `"A 버스는 10분마다, B 버스는 15분마다 온다. 두 버스가 동시에 도착하는 시간은?"`과 같이 ㅈ같은 문제를 해결하는 데 도움을 줍니다.

오늘은 이 두 녀석을 구하는 **무식한 방법(?)**부터, 알고리즘 ㅈ고수들이 사용하는 **유클리드 호제법**에 대해서 알아보겠습니다.

----------

## 최대공약수

공약수<sup style="color:gray">Common Divisor</sup>란, 두 개 이상의 수에 대해 공통되는 수를 말합니다.

- $12$의 약수: $1, 2, 3, 4, 6, 12$
- $18$의 약수: $1, 2, 3, 6, 9, 18$

두 수의 약수 중에서 공통되는 수로 $1, 2, 3, 6$이 있습니다. 바로, 이 수를 공약수라고 합니다. 그리고 이 공약수 중에서 가장 큰 수를 **<span style="color:red">최대</span>공약수**라고 합니다.

피자와 치킨이 각각 12조각과 18조각이 있다고 해봅시다. 한 사람당 똑같이 먹으려면 최대 몇 조각씩 잘라야 할까요? 이를 최대공약수를 통해 구할 수 있으며, 정답은 6조각씩입니다.

### 무식한 방법

최대공약수란 무엇이라했죠? 두 개 이상의 수에서 공통으로 나눌 수 있는 가장 큰 수라고 했습니다.

컴퓨터의 계산 속도는 빠르니 1부터 하나씩 두 수가 나누어지는 지 확인하면 될 것 같습니다.

```cpp
int getGCD(int A, int B) {
    int result = 1;
    for (int i = 1; i <= std::min(A, B); ++i) {
        if (A % i == 0 && B % i == 0) {
            result = i;
        }
    }

    return result;
}
```

로직은 정말 간단합니다. 1부터 시작해서 `A`와 `B` 중 작은 수까지 늘려가며, 두 수가 모두 나누어 지는지 확인합니다. 

그런데, 왜 작은 수까지만 반복하냐구요? `A`와 `B`의 공약수들을 보면, `A`와 `B`보다 큰 수는 없기 때문에 두 수 중 가장 작은 값까지만 확인하는 겁니다. 굳이 큰 수를 선택해서 연산량을 늘릴 필욘 없죠.

그거 아시나요? 이 방법의 단점은 **매우 느리다**는 것입니다. 주어진 수가 10억이라면 10억 번을 연산해야 합니다. 즉, 시간복잡도는 $O(N)$으로 비효율적입니다.

### 유클리드 호제법

기원전 300년 전 수학자 유클리드의 저서에 작성된 것이 발견되어 유클리드 호제법이라 불립니다.

이 알고리즘은 나눗셈을 반복하면 최대공약수가 툭! 하고 나온다는 원리입니다. 정확하게는 두 수 `A`와 `B`의 최대공약수는 `B`와 `A`를 `B`로 나눈 나머지의 최대공약수와 같다는 것입니다. 이 과정을 나머지가 **0**이 될 때까지 반복하면, 그때 나누는 수가 바로 최대공약수라는 것입니다.

$GCD(A, B) = GCD(B, A \% B)$

```cpp
int getGCD(int A, int B) {
    while (B != 0) {
        int temp = B;
        B = A % B;
        A = temp;
    }

    return A;
}

// 재귀 호출을 이용한 방법으로, 1줄로 간단하게 사용할 수 있다.
int getGCD_Recursive(int A, int B) {
    return B == 0 ? A : getGCD_Recursive(B, A % B);
}
```

무식한 방법(?)보다 코드의 줄이 더 짧습니다. 외우기도 편하구요.

이 방법의 시간복잡도는 $O(\log N)$으로, 숫자가 아무리 커도 순식간에 답을 찾아냅니다.

아래는 987과 610의 최대공약수를 유클리드 호제법으로 구할 때의 과정입니다.

| 단계 | A    | B    | A % B |
| :--- | :--- | :--- | :---- |
| 1    | 987  | 610  | 377   |
| 2    | 610  | 377  | 233   |
| 3    | 377  | 233  | 144   |
| 4    | 233  | 144  | 89    |
| 5    | 144  | 89   | 55    |
| 6    | 89   | 55   | 34    |
| 7    | 55   | 34   | 21    |
| 8    | 34   | 21   | 13    |
| 9    | 21   | 13   | 8     |
| 10   | 13   | 8    | 5     |
| 11   | 8    | 5    | 3     |
| 12   | 5    | 3    | 2     |
| 13   | 3    | 2    | 1     |
| 14   | 2    | 1    | 0     |

> **세 개 이상의 수에서 최대공약수를 어떻게 구하죠?**
>
> ```cpp
> int getGCDThree(int A, int B, int C) {
>   return getGCD(getGCD(A, B), C);   
> }
> ```
>
> `N`개도 똑같이 반복하면 됩니다.
{: .prompt-tip }

### STL 함수

C++ 17 이상부터 `<numeric>` 헤더 파일 안에 `std::gcd()` 함수가 있습니다. 왜 이제 알려주냐구요? 적어도 로직은 알아야죠...

```cpp
#include <iostream>
#include <numeric> // C++17 이상

int main(int argc, char* argv[]) {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);

    int num1 = 12, num2 = 18;
    std::cout << "GCD: " << std::gcd(num1, num2) << '\n';

    return 0;
}
```
<samp>6</samp>

편하죠? 하지만, 코딩테스트 등의 환경이 C++ 14까지만 지원하면 위 기능은 사용할 수 없습니다.

----------

## 최소공배수

공배수<sup style="color:gray">Common Multiple</sup>란, 두 개 이상의 수의 배수 중 공통되는 수를 말합니다.

- $12$의 배수: $12, 24, 36, 48, 60, 72, 84, 96, 108, 120, ...$
- $18$의 배수: $18, 36, 54, 72, 90, 108, 126, 144, 162, 180, ...$

두 수의 배수 중에서 공통되는 배수는 $36, 72, 108, ...$로, 이 수를 공배수라고 합니다. 그리고 이 공배수 중에서 가장 작은 수를 **<span style="color:red">최소</span>공배수**라고 합니다.

$LCM(A, B) = \frac{A \times B}{GCD(A, B)}$

LCM을 구하는 공식은 위와 같습니다. 그냥 외우시는 게 좋습니다. (협박입니다.)

### **위 공식이 성립하는 이유?**

1.  **소인수분해**

    $12 = 2^2 \times 3^1$
 
    $18 = 2^1 \times 3^2$
2.  **최대공약수는 공통 소인수 중 지수가 낮은 것을 곱함**

    | 소인수 | 12의 지수 | 18의 지수 | GCD                |
    | :----- | :-------- | :-------- | :----------------- |
    | 2      | 2         | 1         | $\min(2, 1) = 2^1$ |
    | 3      | 1         | 2         | $\min(1, 2) = 3^1$ |

    $GCD(12, 18) = 2^1 \times 3^1 = 6$
3.  **최소공배수는 공통 소인수 중 지수가 높은 것을 곱함**

    | 소인수 | 12의 지수 | 18의 지수 | GCD                |
    | :----- | :-------- | :-------- | :----------------- |
    | 2      | 2         | 1         | $\max(2, 1) = 2^2$ |
    | 3      | 1         | 2         | $\max(1, 2) = 3^2$ |

    $LCM(12, 18) = 2^2 \times 3^2 = 36$
4.  **패턴이 보임**

    $GCD \times LCM = (2^1 \times 3^1) \times (2^2 \times 3^2)$
    
    $= 2^{1+2} \times 3^{1+2}$

    $= 2^3 \times 3^3$

    $= 8 \times 27 = 216$

    $A \times B = 12 \times 18 = 216$으로, $GCD \times LCM = A \times B$가 성립됨.
5.  **정리**
 
    즉, $A \times B = GCD(A, B) \times LCM(A, B)$로,
    
    $LCM(A, B) = (A \times B) \div GCD(A, B)$이다.

### 로직

자, 공식을 알았으니 코드로 옮겨볼까요?

```cpp
int getLCM(int A, int B) {
    return (A * B) / getGCD(A, B);
}
```

그런데, 위 코드는 매우 위험한 코드입니다. 왜 그럴까요?

왜냐하면, `A`와 `B`를 먼저 곱하면 숫자가 너무 커져 `int` 자료형의 크기를 넘기는 **오버플로우**가 발생할 가능성이 있습니다. 

그래서 위 코드처럼 작성하면 절대 안 되고, 아래와 같이 먼저 나눈 뒤에 곱해주는 방식을 취해야 합니다.

```cpp
// 먼저 나누어도... int 자료형도 위험할 수 있다.
// 더 안전하게 long long을 사용
long long getLCM(int A, int B) {
    return ((long long)A / getGCD(A, B)) * B;
}
```

#### 나누고 곱하는 데, 올바른 답이 나오는 이유

1.  **A와 B는 GCD를 공통으로 갖고 있다**
    
    $A = GCD(A, B) \times a, B = GCD(A, B) \times b$

    여기서,

    $a = \frac{A}{GCD(A, B)}, b = \frac{B}{GCD(A, B)}$

    로, $a$와 $b$는 서로소입니다.
    
    최소공배수는

    $LCM(A, B) = GCD(A, B) \times a \times b$
2.  **`A * B`를 먼저 할 경우**
    
    $LCM(A, B) = \frac{A \times B}{GCD(A, B)}$

    여기서, A와 B를 대입하면

    $\frac{(GCD(A, B) \times a)(GCD(A, B) \times b)}{GCD(A, B)} = GCD(A, B) \times a \times b$

    수학적으로 보면(?) 괜찮아 보이지만, 계산 순서에서 $A \times B$에서 값이 너무 커져 오버플로우가 발생할 수 있다.
3.  **먼저 나누고 곱해볼까?**
    
    $G = GCD(A, B), A = G \times a, B = G \times b$

    일 때, $\frac{A}{G} \times B$의 연산을 수행하면 다음과 같다.

    $\frac{G \times a}{G} \times (G \times b) = a \times G \times b = G \times a \times b$

    결과가 `A * B`인 것과 동일하다. 줄어든 값으로 곱하면 원래의 값과 수학적으로 동일하다는 것을 알 수 있습니다.

    게다가 $G$는 $A$의 약수이기 때문에 항상 정수로 나타납니다.

### STL 함수

최대공약수와 마찬가지로 C++ 17 이상부터 `<numeric>` 헤더 파일 안에 `std::lcm()` 함수가 있습니다.

```cpp
#include <iostream>
#include <numeric> // C++17 이상

int main(int argc, char* argv[]) {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);

    int num1 = 12, num2 = 18;
    std::cout << "GCD: " << std::gcd(num1, num2) << '\n';
    std::cout << "LCM: " << std::lcm(num1, num2) << '\n';

    return 0;
}
```
<samp>GCD: 6<br>LCM: 36</samp>

----------

## 시간복잡도

| 개념            | 뜻                     | 공식                          | 시간복잡도  | 주의사항      |
| :-------------- | :--------------------- | :---------------------------- | :---------- | :------------ |
| GCD(최대공약수) | 공약수 중 제일 큰 수   | 유클리드 호제법               | $O(\log N)$ | `0` 처리 주의 |
| LCM(최대공약수) | 공배수 중 제일 작은 수 | $(A \div GCD(A, B)) \times B$ | $O(\log N)$ | 오버플로우    |

----------

## 마무리

1.  최대공약수는 유클리드 호제법을 이용해 빠르게 구할 수 있다.
2.  최소공배수는 기본적으로 $A \times B \div GCD(A, B)$지만, 오버플로우 발생 가능성이 있어 먼저 나눈 후 곱한다.
3.  C++ 17 이상에선 `<numeric>` 헤더 파일 안에 있는 `std::gcd()`와 `std::lcm()`을 사용하는게, 정신 건강에 좋다.

----------

## 추천 문제
### [⚔️ 백준 2609번 - 최대공약수와 최소공배수](https://www.acmicpc.net/problem/2609 "백준 2609번 - 최대공약수와 최소공배수")

<details>

```cpp
#include <iostream>

int GCD(int A, int B) {
    while (B != 0) {
        int temp = B;
        B = A % B;
        A = temp;
    }

    return A;
}

int LCM(int A, int B) {
    return (A / GCD(A, B)) * B;
}

int main(int argc, char* argv[]) {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);

    // A, B
    int A, B; std::cin >> A >> B;

    std::cout << GCD(A, B) << '\n';
    std::cout << LCM(A, B) << '\n';

    return 0;
}
```

C++ 17 이상을 사용할 경우 `<numeric>`을 사용하여 손쉽게 해결할 수 있습니다. 하지만, 17 미만의 버전을 사용 중이라면 위 소스 코드와 같이 작성해야 합니다.

</details>

### [⚔️ 백준 1934번 - 최소공배수](https://www.acmicpc.net/problem/1934 "백준 1934번 - 최소공배수")

<details>

```cpp
#include <iostream>

int GCD(int A, int B) {
    while (B != 0) {
        int temp = B;
        B = A % B;
        A = temp;
    }

    return A;
}

int LCM(int A, int B) {
    return (A / GCD(A, B)) * B;
}

int main(int argc, char* argv[]) {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);

    // T
    int T; std::cin >> T;
    for (int t = 0; t < T; ++t) {
        // A, B
        int A, B; std::cin >> A >> B;

        std::cout << LCM(A, B) << '\n';
    }

    return 0;
}
```

여러 개의 테스트 케이스의 입력이 주어지며, 단순하게 최소공배수를 구하면 되는 문제입니다.

</details>

### [⚔️ 백준 5347번 - LCM](https://www.acmicpc.net/problem/5347 "백준 5347번 - LCM")

<details>

```cpp
#include <iostream>

int GCD(int A, int B) {
    while (B != 0) {
        int temp = B;
        B = A % B;
        A = temp;
    }

    return A;
}

long long LCM(int A, int B) {
    return ((long long)A / GCD(A, B)) * B;
}

int main(int argc, char* argv[]) {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);

    // T
    int T; std::cin >> T;
    for (int t = 0; t < T; ++t) {
        // A, B
        int A, B; std::cin >> A >> B;

        std::cout << LCM(A, B) << '\n';
    }

    return 0;
}
```

[⚔️ 백준 1934번 - 최소공배수](https://www.acmicpc.net/problem/1934 "백준 1934번 - 최소공배수")와 같습니다.

다만, `A`와 `B`가 1'000'000까지의 범위를 갖기 때문에 오버플로우를 주의해야 합니다.


</details>

### [⚔️ 백준 9613번 - GCD 합](https://www.acmicpc.net/problem/9613 "백준 9613번 - GCD 합")

<details>

```cpp
#include <iostream>
#include <vector>

int GCD(int A, int B) {
    while (B != 0) {
        int temp = B;
        B = A % B;
        A = temp;
    }

    return A;
}

int main(int argc, char* argv[]) {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);

    // T
    int T; std::cin >> T;
    for (int t = 0; t < T; ++t) {
        // N, ...
        int N; std::cin >> N;

        // Arr
        std::vector<int> Arr(N, 0);
        for (int j = 0; j < N; ++j) std::cin >> Arr[j];

        // Brute-Force
        long long sum = 0;
        for (int i = 0; i < N - 1; ++i) {
            for (int j = i + 1; j < N; ++j) {
                sum += GCD(Arr[i], Arr[j]);
            }
        }

        std::cout << sum << '\n';
    }

    return 0;
}
```

가능한 모든 쌍의 최대공약수를 구해 합한 후 출력하면 되는 문제입니다.

우리는 아직 완전 탐색에 대해 배우지 않았기 때문에 생각보다 어려울 수 있습니다만, 조금만 머리를 쓰면 풀 수 있는 문제이기에 포함했습니다.

그리고 합산 결과가 `int`를 넘을 수 있기에 주의하셔야 합니다.

</details>

### [⚔️ 백준 2436번 - 공약수](https://www.acmicpc.net/problem/5347 "백준 2436번 - 공약수")

<details>

```cpp
#include <climits>
#include <iostream>

long long GCD(long long A, long long B) {
    while (B != 0) {
        int temp = B;
        B = A % B;
        A = temp;
    }

    return A;
}

int main(int argc, char* argv[]) {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
    
    // G, L
    long long G, L;
    std::cin >> G >> L;

    long long target = L / G;
    long long min = LLONG_MAX;
    long long A = 0, B = 0;

    for (long long i = 1; (i*i) <= target; ++i) {
        // 약수가 아니라면 생략
        if (target % i != 0) continue;

        long long first = i;                    // 약수 쌍의 첫 번째 값
        long long second = target / i;          // 약수 쌍의 두 번째 값

        // 서로소 체크
        if (GCD(first, second) == 1) {
            long long sum = first + second;              // A와 B의 합
            if (sum < min) {
                min = sum;
                A = first;
                B = second;
            }
        }
    }

    // A와 B 구하기
    A *= G; B *= G;

    // 오름차순 출력
    if (A > B) {
        std::cout << B << ' ' << A;
    } else {
        std::cout << A << ' ' << B;
    }

    return 0;
}
```

굉장히 난이도가 있는 문제입니다. 이 문제 푸는 데 시간이 좀 걸렸습니다.

이 문제에서 우리가 찾아야 하는 건 `A`와 `B`입니다. [이곳](#나누고-곱하는-데-올바른-답이-나오는-이유)의 내용을 조금 참고해보면 `A`와 `B`는 공통적으로 `GCD`를 갖고 있음을 알 수 있습니다.

즉, $A = G \times a$이고, $B = G \times b$입니다. 여기서, $a$와 $b$는 서로소입니다.

$L = \frac{(A \times B)}{G} = G \times a \times b$로, 우리는 최종적으로 $a$와 $b$를 찾아야 합니다. 왜냐하면 우리는 문제에서 주어진 $G$를 알고있기 때문입니다.

여기서, 우리가 원하는 건 서로소 $a$와 $b$입니다. 이를 구하기 위해 $G$로 나눕니다. 그러면 $\frac{L}{G} = \frac{G \times a \times b}{G} = a \times b$임을 알 수 있습니다.

$a \times b = target$으로, $target$을 만들 수 있는 모든 수를 검사하기 위해 $target$의 약수를 구해야 합니다. 그리고 이 약수 쌍의 최대공약수를 구해서 값이 `1`인지 확인합니다. 왜냐하면 `1`로 반환되면 1 외 공약수가 없기 때문에 서로소라는 의미이기 때문입니다.

그리고 약수 쌍의 $(first, second)$를 구합니다. 그리고 $first + second$의 값을 더해 $min$ 값과 비교하여 갱신합니다. 이곳에서 `A`와 `B`를 구하지 않는 건 굳이 내부에서 연산을 수행해서 효율을 낮출 필요가 없기 때문입니다.

반복문 연산이 끝난 후 마지막에 $G \times A, G \times B$를 하면 답을 구할 수 있습니다.

</details>