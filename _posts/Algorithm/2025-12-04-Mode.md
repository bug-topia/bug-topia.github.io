---
title: C++ 알고리즘) 최빈값
date: 2025-12-04 00:18:00 +0900
categories: ['Algorithm']
tags: ['Algorithm', 'Mode', '알고리즘', '최빈값' ]
math: true
---

> 개인적으로 공부한 내용을 복습 겸 강좌 형식으로 작성한 글입니다. 잘못된 정보, 오타 등이 포함되어 있을 수 있습니다.
{: .prompt-warning }

## 서론

앞서 우리는 배열에서 **[가장 작은 값과 가장 큰 값](/posts/MinMax "최솟값과 최댓값")**을 찾는 방법을 배웠습니다. 이는 데이터를 값의 크기를 기준으로 비교하는 기본적인 로직이었죠.

이번에는 이 기본기를 활용하여 **가장 자주 등장하는 값**, 즉 최빈값을 찾아봅시다.

----------

## 💡 최빈값

최빈값<sup style="color:gray">Mode</sup>은 주어진 데이터 집합에서 **가장 자주 등장하는 값**을 의미합니다.

예를 들어, 학생들의 점수 배열 $A = \{80, 70, 90, 80, 70, 80\}$가 있다면, 70점은 2번, 90점은 1번, **80점은 3번** 등장했습니다. 따라서 **최빈값은 80**입니다.

최빈값을 구하는 로직은 **'횟수를 세는 단계'**와 **'가장 많은 횟수를 찾는 단계'**의 두 부분으로 구성됩니다.

### 드랍된 아이템의 등급 확인

RPG 게임에서 몬스터를 사냥해서 얻은 드랍된 아이템들의 등급을 분석한다고 가정해 봅시다. 등급은 1~5점 사이의 정수 숫자로 표현된다고 하구요.

| 드랍된 아이템의 등급 리스트 | $\{ 3, 5, 2, 4, 3, 3, 5, 3 \}$ |
| :-------------------------- | :----------------------------- |
| **등장 횟수**               | 3점짜리 아이템이 4번 나옴      |
| **최빈값**                  | 3                              |

최빈값을 구하려면 어떻게 해야할까요? 음... 생각보다 어렵죠? 아래의 단계를 따라하면서 자연스럽게 익혀봅시다.

1.  **빈도 수 배열 활용**
    
    최빈값을 구하려면 먼저 각 등급이 몇 번 나왔는지 계산해야 합니다. 이를 위해 빈도 수 배열<sup style="color:gray">Frequency Array</sup>을 사용합니다. 이름이 거창해서 그렇지, 단순히 몇 번 나왔는 지 기록해두는 배열입니다.
2.  **빈도 수 계산**
    
    드랍된 아이템 리스트를 순회하며, **각 등급의 값을 배열의 인덱스로 사용**하여 해당 횟수를 `1`씩 증가시킵니다.
3.  **최대 빈도 찾기**
    
    빈도 수 배열을 순회하면서 **가장 높은 빈도수(최댓값)**을 찾습니다. 인덱스도 기록해야 한다면, 이때 같이 기록합니다.

```cpp
#include <algorithm>
#include <iostream>
#include <vector>

int main(int argc, char* argv[]) {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);

    // 드랍된 아이템의 등급이 담긴 배열
    std::vector<int> item_grades = { 3, 5, 2, 1, 5, 2, 3, 5, 2, 1, 1, 3, 4, 2, 3 };

    // 1) 빈도수 배열 준비
    // 아이템의 등급이 1부터 시작하기 때문에, 1-based 인덱스로 시작하기 위해 1을 더한다.
    std::vector<int> freq(5 + 1, 0);

    // 2) 빈도수 계산
    for (const auto& grade : item_grades) {
        // 등장 횟수
        freq[grade] += 1;
    }

    // 3) 최대 빈도 찾기
    int max_freq = 0;           // 가장 높은 빈도 수
    int mode_grade = 0;         // 가장 높은 빈도 수를 가진 아이템의 등급

    for (int i = 1; i < freq.size(); ++i) {
        if (freq[i] > max_freq) {
            max_freq = freq[i];
            mode_grade = i;
        }
    }

    std::cout << "가장 많이 드랍된 아이템의 등급: " << mode_grade << '\n';
    std::cout << "가장 많이 드랍된 아이템의 횟수: " << max_freq << '\n';

    return 0;
}
```
<samp>가장 많이 드랍된 아이템의 등급: 2<br>가장 많이 드랍된 아이템의 횟수: 4</samp>

| 아이템의 등급 | 등장 횟수 |
| :------------ | :-------- |
| 1             | 3         |
| 2             | 4         |
| 3             | 4         |
| 4             | 1         |
| 5             | 3         |

위 표를 보시면 실행 결과에 의문이 생기지 않나요? 네, 바로 중복되는 경우에 대한 대처입니다.

최빈값을 구할 때 **가장 빈도수가 높은 값이 두 개 이상**일 수 있습니다. 이러한 중복 최빈값 상황을 어떻게 처리할지는 주어진 문제의 요구사항을 따라야 합니다.

1.  **가장 먼저 나타나는 값으로**
    
    가장 높은 빈도수를 찾았을 때, 이미 찾은 값과 같거나 작은 값은 무시하고, 더 높은 빈도수가 나타났을 때만 갱신하는 방식입니다.

    최빈값이 여러 개라면 가장 작은 값을 출력하라는 문제에서 요구하는 부분이죠.
2.  **가장 나중에 나타나는 값으로**
    
    가장 높은 빈도수를 찾았을 때, 이미 찾은 값과 같거나 큰 값이라면 새로운 값으로 갱신하는 방식입니다.

    최빈값이 여러 개라면 가장 큰 값을 출력하라는 문제에서 요구하는 부분이죠.
3.  **중복된 최빈값 모두 출력**
    
    최빈값 후보들을 모두 저장해야 하는 경우입니다.

    가장 먼저 `max_freq`(최빈값)을 구합니다. 그리고 `max_freq`와 같은 횟수를 가진 인덱스를 별도의 배열에 담습니다.

#### ⚠️ 주의사항

우리가 최빈값을 구하기 위해 사용한 빈도수 배열은 입력 숫자의 범위가 작을 때 효율적으로 작동합니다.

예를 들어, 만약 입력 범위의 숫자가 1부터 $2^{31}$의 범위일 때, $2^{31}$의 크기를 갖는 배열을 만드는 건 엄청난 부담이 됩니다. 그래서 `std::unordered_map` 등의 자료구조를 사용하여 빈도 수를 기록해야 합니다. (이 부분은 이후에 다룹니다.)

----------

## 시간복잡도

최빈값 로직의 시간복잡도는 $O(N + R)$입니다.

- $O(N)$: 아이템 리스트($N$)를 순회하며 빈도수를 계산
- $O(R)$: 빈도수 배열($R$)을 순회하며 최대 빈도수를 찾는 계산

아이템의 수가 많더라도 등급 범위가 작다면 $O(N)$에 가까운 효율적인 방법입니다.

----------

## 마무리

최빈값은 주어진 데이터 집합에서 가장 자주 등장하는 값입니다. 중복되는 경우가 발생할 수 있으며, 이는 문제에서 요구하는 사항에 따라 처리해야 합니다.

----------

## 추천 문제
### [⚔️ 백준 2592번 - 대표값](https://www.acmicpc.net/problem/2592 "백준 2592번 - 대표값")

<details>

```cpp
#include <iostream>
#include <vector>

int main(int argc, char* argv[]) {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);

    // 합계 저장 변수
    int s = 0;

    // 배열 입력 받기
    std::vector<int> Arr(1000, 0);
    for (int i = 0; i < 10; ++i) {
        int x; std::cin >> x;
        s += x;
        Arr[x] += 1;
    }

    // 평균 출력
    std::cout << (s / 10) << '\n';

    // 최빈값 구하기
    int max_freq = 0;
    int max_mode = 0;
    for (int i = 10; i < 1000; i += 10) {
        if (max_freq < Arr[i]) {
            max_freq = Arr[i];
            max_mode = i;
        }
    }

    std::cout << max_mode;

    return 0;
}
```
{: .blur-hover }

> 위 코드는 최적화가 더 가능합니다.
>
> 1000 미만의 10의 배수만 입력된다고 합니다. 즉, $1000 / 10 = 100$을 배열의 크기로 잡고, 인덱스를 `value / 10`으로 변환하여 사용할 수 있습니다.
{: .prompt-tip .blur-hover  }

</details>