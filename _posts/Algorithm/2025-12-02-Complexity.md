---
title: C++ 알고리즘) 시간복잡도와 공간복잡도
date: 2025-12-02 22:48:00 +0900
categories: ['Algorithm']
tags: ['Algorithm', 'Time Complexity', 'Space Complexity', '알고리즘', '시간복잡도', '공간복잡도' ]
math: true
---

> 개인적으로 공부한 내용을 복습 겸 강좌 형식으로 작성한 글입니다. 잘못된 정보, 오타 등이 포함되어 있을 수 있습니다.
{: .prompt-warning }

## 서론

알고리즘을 공부할 때 가장 먼저 마주치는 개념이 있습니다. 바로, **시간복잡도**와 **공간복잡도** 그리고 이를 표현하는 **Big-O 표기법**입니다. 마치 C언어를 배울 때 포인터와 재귀 호출을 만나는 격(?)입니다.

문제는,,, 이 개념을 설명하는 대부분의 글이 $f(n) = O(g(n))$ 같은 수식과 이해하기 힘든 그래프를 들고 와서 사람을 압박하며(?), 알고리즘 공부 의욕을 한 단계 나락으로 끌고 간다는 점입니다.

그래서 이 글은 수학적인 부담을 최대한 내려놓고, 개발자의 언어로 최대한 자연스럽게 이해시키는 데 집중했습니다. 그만큼 이론적인 부분은 부족하니 양해바랍니다.

----------

## 시간복잡도 (Time Complexity)

> A의 컴퓨터에서 0.1초 걸렸고, B의 컴퓨터에선 1초 걸렸으니... A가 무조건 더 좋은 알고리즘이군...

알고리즘을 처음 배울 때 흔히 하는 착각이자 혼동입니다. 함정이기도 하죠.

실행 시간은 컴퓨터의 성능, 컴파일러의 최적화 옵션, 현재 실행 중인 다른 프로그램, 심지어는 컨디션(?)에 따라 달라지기도 합니다. 슈퍼 컴퓨터에선 0.001초로 줄어들 수 있지만, 존나 구진 노트북에선 100초가 걸릴 수 있죠.

그래서 우리는 **절대적인 시간(초)**이 아니라, **입력 크기(`N`)가 커질 때 연산 횟수가 어떻게 증가하는가**를 봐야합니다.

> **비밀번호 찾기 예시**
>
> 4자리 숫자 비밀번호를 무작위 대입으로 찾는다고 해봅시다. 최악의 경우 0000 ~ 9999까지 **10,000번**을 시도해야 합니다.
>
> 그런데 비밀번호가 패치되어 6자리로 늘어난다면??? 100만 번을 시도해야 하고, 8자리면 1억 번입니다... 😅
>
> 자릿수가 조금 늘어났을 뿐인데 시도 횟수는 10배, 100배씩 폭발합니다. 이게 바로 시간복잡도의 핵심입니다.
>
> 결국 중요한 건 '지금 내 코드가 몇 초 걸리냐'가 아니라, **데이터가 10배, 100배 커졌을 때 내 코드가 멈추지 않고 살아남을 수 있느냐**입니다.
{: .gh-alert.note }

----------

## Big-O 표기법

Big-O(빅오)는 간단히 말해서 **입력(`N`)이 존나게 커졌을 때, 연산 횟수가 대략 어떤 패턴으로 늘어나는가**를 나타냅니다.

1.  **최악의 경우를 기준으로 한다.**
    
    왜 하필 최악의 경우일까요? 알고리즘 대회나 실무에선 '운이 좋아서 빨리 끝나는 경우'가 없기 때문입니다.

    데이터가 꼬일 대로 꼬였을 때도 제한 시간 안에 실행할 수 있어야 안심할 수 있기 때문입니다. 그래서 Big-O는 일종의 상한선(Upper Bound)을 보장해 주기도 합니다.

    여담으로, 평균과 최선을 나타내기도 하지만 보조 개념 정도로만 사용합니다.
2.  **상수와 낮은 차수의 항은 개같이 무시한다.**
    
    수식 $5N^2 + 100N + 1000$은 $O(N^2)$로 표기합니다. N이 커지면 상수 1000이나, 계수 5는 전체 증가 추세에 그리 큰 영향을 주지 않기 때문입니다. 가장 영향력이 큰 항만 남기고, 나머지는 과감히 버립니다.
{: .large-numbers }

### 게임 비유로 이해하는 Big-O

| Big-O         | 이름           | N이 10배 커졌을 때 연산 횟수 | 게임 비유                                                                                       |
| :------------ | :------------- | :--------------------------- | :---------------------------------------------------------------------------------------------- |
| $O(1)$        | 상수 시간      | 변화 없음                    | 게임에서 스킬 버튼을 누름. 스킬 딜레이 개념과는 별개로 스킬 시전에 접근하는 것은 같기 때문      |
| $O(\log N)$   | 로그 시간      | 아주 조금씩 증가             | 배그의 자기장이 절반씩 줄어드는 경우, 10억 명이 있을 때 운이 좋으면 30번 안에 나만 남을 수 있음 |
| $O(N)$        | 선형 시간      | 10배                         | 스타에서 마린 100기에게 하나하나 이동 명령 내리기 (유닛수만큼 클릭)                             |
| $O(N \log N)$ | 선형 로그 시간 | 30~40배                      | 롤 랭크전에서 전세계 플레이어를 실력순(MMR)으로 정렬한 후 매칭                                  |
| $O(N^2)$      | 제곱 시간      | 100배                        | 스타에서 저글링 100마리가 서로 부딪히며 뭉칠 때 충돌 체크                                       |
| $O(2^N)$      | 지수 시간      | 1024배                       | 카드 게임에서 30장으로 만들 수 있는 모든 덱 조합으로 시뮬레이션                                 |
| $O(N!)$       | 팩토리얼       | 불가능 수준                  | 파티 게임에서 모든 경우의 수                                                                    |

$O(1)$에 가까울수록 가장 빠르고, $O(N^2)$부터는 데이터 크기에 따라 주의해야 하는 단계입니다.

### C++ 코드로 이해하기
```cpp
// 1부터 N까지의 합: O(1)
int S1 = (N * (N + 1)) >> 1;

// 점수 합산: O(N)
int S2 = 0;
for (int i = 0; i < N; ++i) {
    S2 += scores[i];
}

// N명의 사람이 서로 악수하는 경우: O(N^2)
for (int i = 0; i < N; ++i) {
    for (int j = 0; j < N; ++j) {
        std::cout << i << "와 " << j << "가 서로 악수함\n";
    }
}
```

### 코딩테스트 시 시간복잡도 기준표

| N의 범위              | 안전한 시간복잡도       | 비고                                                         |
| :-------------------- | :---------------------- | :----------------------------------------------------------- |
| $N \le 100$           | $O(N^3)$                | 플로이드-워셜 알고리즘 등                                    |
| $N \le 5,000$         | $O(N^2)$                | 많이 봐주면 $N \le 10,000$까지, 누적합 사용 필요할 때도 있음 |
| $N \le 100,000$       | $O(N \log N)$           | 정렬, 이분 탐색 등                                           |
| $N \le 1,000,000$     | $O(N)$                  | 투 포인터, 그리디 등                                         |
| $N \le 1,000,000,000$ | $O(\log N)$ 또는 $O(1)$ | 수학적 공식 필요                                             |

----------

## 공간복잡도 (Space Complexity)

시간복잡도가 '얼마나 느려지냐'라면, 공간복잡도는 '얼마나 많은 메모리를 쳐먹느냐'입니다. 표기법은 시간복잡도와 동일하게 Big-O를 사용합니다.

요즘은 워낙에 메모리가 넉넉해서 시간복잡도보다는 덜 중요하게 여겨지기도 합니다. 하지만, **메모리 제한 128MB** 같은 조건이 걸린 문제에서 무턱대고 큰 배열을 선언했다간 MLE(Memory Limit Exceeded)를 영접할 수 있습니다.

| 상황                   | 공간복잡도 | 설명                                     |
| :--------------------- | :--------- | :--------------------------------------- |
| `int a`                | $O(1)$     | 입력 `N`과 상관없이 변수 몇 개만 사용    |
| `std::vector<int> vec` | $O(N)$     | 데이터의 개수만큼 배열(메모리) 공간 필요 |
| `int Arr[N][N]`        | $O(N^2)$   | 그래프 인접 행렬, 2차원 DP 테이블 등     |

> 재귀 함수를 사용할 때도 스택 메모리가 쌓입니다.
> 
> 재귀의 깊이가 `N`만큼 깊어지면 공간복잡도도 그만큼 $O(N)$이 됩니다.
{: .prompt-tip }

----------

## 시간과 공간, 무엇이 더 중요할까?

결론부터 말하자면 정답은 없습니다. 문제의 조건에 따라 다른데, 알고리즘의 세계에서(?) 중요한 법칙이 하나 있습니다.

바로 시간과 공간의 등가교환(Time-Space Trade-Off)입니다. 즉, 살을 주고 뼈를 취하는 그런 전략입니다.

메모리를 사용해서 시간을 줄이거나, 메모리가 부족해 시간을 더 써서 계산하는 겁니다.

보통은 메모리를 조금 더 쓰더라도 시간을 단축시키는 쪽을 선호합니다. 왜냐하면 한국인 성격상(?) 1초라도 느린 건 못참잖아요. 사실 컴퓨터가 메모리 10MB 더 사용한다고 사용자가 눈치를 잘 챌까요?

----------

## 마무리

처음 알고리즘을 접하면 "이 코드가 $O(N \log N)$인가 $O(N^2)$인가?" 판별하는 게 쉽지 않습니다. 못하는 게 정상입니다. 

우선은 딱 하나만 기억하세요. "내 코드에 겹쳐있는 반복문이 몇 개인가?" 반복문이 하나면 $O(N)$, 반복문 안에 반복문이 있다면 $O(N^2)$라고 단순하게 접근해도 초기 단계에선 충분합니다.

복잡한 수식보다는 데이터가 커질 때 내 코드가 얼마나 힘겨워할지를 상상하는 감각을 익히는 것이 훨씬 중요합니다. 이 감각이 익숙해지면 나중에는 문제를 읽자마자 "아, 이건 N이 10만이니까 $O(N^2)$으로 짜면 터지겠네? $O(N \log N)$으로 풀어야겠다."라는 견적이 바로 나오게 될 겁니다.

----------

## 추천 문제
### [⚔️ 백준 - 시간복잡도](https://www.acmicpc.net/step/53 "백준 - 시간복잡도")