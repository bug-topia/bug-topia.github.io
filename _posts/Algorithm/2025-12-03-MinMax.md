---
title: C++ 알고리즘) 최솟값과 최댓값
date: 2025-12-03 21:32:00 +0900
categories: ['Algorithm']
tags: ['Algorithm', 'Min', 'Max', '알고리즘', '최솟값', '최댓값' ]
math: true
---

> 개인적으로 공부한 내용을 복습 겸 강좌 형식으로 작성한 글입니다. 잘못된 정보, 오타 등이 포함되어 있을 수 있습니다.
{: .prompt-warning }

## 서론

알고리즘을 막 시작하면 제일 먼저 만나는 문제가 있습니다. 

<span class="focus-font">주어진 데이터 중에서 가장 작은 값과 제일 큰 값을 찾아라.</span>

사실 이 문제는 알고리즘의 세계가 아니더라도, 일상생활 속에서 늘 마주치고 있습니다.

- **쇼핑할 때**: **가장 저렴한** 화장품의 가격은 얼마지?
- **시험 성적을 확인할 때**: 우리 반에서 **가장 높은** 점수를 받은 녀석은 누구지?
- **투자할 때**: 이번 달 **가장 크게** 떨어진 종목은 뭐지?

이처럼 우리는 수 많은 값 중에서 특정한 최대 또는 최소를 고르는 문제를 반복하고 있습니다. 이 단순한 개념이 나중에 배우게 될 다양한 알고리즘의 기초가 되기 때문에 잘 알아두도록 합시다.

----------

## 💡 최솟값과 최댓값

최솟값<sup style="color:gray">Minimum Value</sup>은 주어진 집합(배열)에 속한 모든 원소 중에서 가장 작은 값을 의미하며, 최댓값<sup style="color:gray">Maximum Value</sup>은 주어진 집합(배열)에 속한 모든 원소 중에서 가장 큰 값을 의미합니다.

예를 들어, 배열 $A = { 5, 3, 1, 2, 4 }$가 있다면, **최솟값은 2**이고 **최댓값은 5**입니다. 이정도는 쉽게 이해되죠.

### 로직을 작성해보자

자, 여러분이 RPG 게임을 즐기고 있다고 가정해 봅시다.

인벤토리의 장비 탭에 착용 가능한 무기가 여러 개 존재하고, 그중 가장 공격력이 높은 무기와 가장 낮은 무기를 찾고 싶습니다. 어떻게 해야할까요?

방법은 간단합니다.

1.  무기들을 하나씩 꺼내서
2.  "지금까지 본 무기 중 가장 강한가?"
3.  "지금까지 본 무기 중 가장 약한가?"
4.  라는 기준으로 비교하며 갱신해 나가면 됩니다.

```cpp
#include <iostream>
#include <vector>

int main(int argc, char* argv[]) {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);

    // 무기의 공격력이 담긴 배열
    std::vector<int> WeaponPowers = { 44, 74, 82, 54, 89, 27, 60, 84, 29, 56 };

    // 현재 최솟값으로 첫 번째 원소를 지정
    int min_val = WeaponPowers[0];

    // 현재 최댓값으로 첫 번째 원소를 지정
    int max_val = WeaponPowers[0];

    // 배열의 모든 원소를 순회
    for (const auto& power : WeaponPowers) {
        if (power < min_val) min_val = power;           // 더 작은 값이 나타나면 갱신
        if (power > max_val) max_val = power;           // 더 큰 값이 나타나면 갱신
    }

    std::cout << "최소 공격력: " << min_val << '\n';
    std::cout << "최대 공격력: " << max_val << '\n';

    return 0;
}
```
<samp>최소 공격력: 27<br>최대 공격력: 89</samp>

#### 주의사항

많은 초보자들이 `min_val`과 `max_val` 변수의 값을 습관적으로(?) `0`으로 초기화합니다. 그러나 이는 심각한 버그를 유발할 수 있습니다.

예를 들어, 배열이 모두 음수라면?

- `max_val = 0`으로 시작하면,
- 모든 값이 `0`보다 작으므로,
- `max_val`은 갱신되지 않고 그대로 `0`이 되어버립니다.

즉, 잘못된 결과를 초래합니다.

이를 방지하는 올바른 초기화 방법은 아래와 같습니다.

1.  **첫 번째 원소로 초기화**
    
    `int max_val = Arr[0]`과 같이 배열의 첫 번째 원소로 안전하게 초기화하는 방법이 있습니다. 
    
    단, 배열이 비어있지 않아야 한다는 전제 조건이 있습니다.
2.  **극한값**
    
    C++ 언어에는 `<climits>`라는 헤더 파일이 존재합니다. 이 헤더 파일 안에 각 자료형의 최솟값과 최댓값을 의미하는 상수가 존재합니다.

    - 최댓값을 구할 땐 `int max_val = INT_MIN`으로
    - 최솟값을 구할 땐 `int min_val = INT_MAX`으로
    
    위와 같이 설정하여 어떤 값이 와도 이보단 작을 것/클 것으로 하는 것입니다.

### STL의 함수 이용하기

`<algorithm>` 헤더 파일 안에 최솟값과 최댓값을 구해주는 함수가 존재합니다. 왜 이제 알려주냐구요? 딸깍으로 편해지기 전에 적어도 로직은 알아야죠...

```cpp
#include <algorithm>
#include <iostream>
#include <vector>

int main(int argc, char* argv[]) {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);

    // 무기의 공격력이 담긴 배열
    std::vector<int> WeaponPowers = { 44, 74, 82, 54, 89, 27, 60, 84, 29, 56 };

    int min_val = *std::min_element(WeaponPowers.begin(), WeaponPowers.end());
    int max_val = *std::max_element(WeaponPowers.begin(), WeaponPowers.end());

    std::cout << "최소 공격력: " << min_val << '\n';
    std::cout << "최대 공격력: " << max_val << '\n';

    return 0;
}
```
<samp>최소 공격력: 27<br>최대 공격력: 89</samp>

`std::min_element()`와 `std::max_element()`는 값이 아닌 위치(Iterator)를 반환합니다. 그래서 앞에 `*`를 붙여야 그 위치에 있는 실제 값을 가져옵니다.

> ```cpp
> auto [min_it, max_it] = std::minmax_element(Arr.begin(), Arr.end());
> std::cout << (*min_it) << ' ' << (*max_it) << '\n';
> ```
>
> C++ 17 이상부터 사용 가능한 문법으로, 두 값을 동시에 구해야 할 때 사용합니다. 이때도 마찬가지로 값이 아닌 위치를 반환하기 때문에 실제 값을 얻으려면 `*`를 수식해야 합니다.
{: .prompt-tip }

### 🔥 (심화) 값이 아닌 위치를 찾아보자

최솟값과 최댓값뿐만 아니라 그게 몇 번째 위치(인덱스)에 있는 지 물어볼 때가 있습니다. 

예를 들면, "가장 강한 무기가 몇 번째 무기인가?", "가장 약한 장비가 몇 번째인가?"와 같은 상황이죠.

```cpp
#include <iostream>
#include <vector>

int main(int argc, char* argv[]) {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);

    // 무기의 공격력이 담긴 배열
    std::vector<int> WeaponPowers = { 44, 74, 82, 54, 89, 27, 60, 84, 29, 56 };

    // 현재 최솟값으로 첫 번째 원소를 지정
    int min_val = WeaponPowers[0];
    int min_idx = 0;

    // 현재 최댓값으로 첫 번째 원소를 지정
    int max_val = WeaponPowers[0];
    int max_idx = 0;

    // 배열의 모든 원소를 순회
    for (int i = 0; i < WeaponPowers.size(); ++i) {
        // 더 작은 값이 나타나면 갱신
        if (WeaponPowers[i] < min_val) {
            min_val = WeaponPowers[i];
            min_idx = i;
        }
        
        // 더 큰 값이 나타나면 갱신
        if (WeaponPowers[i] > max_val) {
            max_val = WeaponPowers[i];
            max_idx = i;
        }
    }

    std::cout << "최소 공격력: " << min_val << ", 위치: " << min_idx << '\n';
    std::cout << "최대 공격력: " << max_val << ", 위치: " << max_idx << '\n';

    return 0;
}
```
<samp>최소 공격력: 27, 위치: 5<br>최대 공격력: 89, 위치: 4</samp>

> ```cpp
> auto min_it = std::min_element(Arr.begin(), Arr.end());
> int min_idx = std::distance(Arr.begin(), min_it);
> ```
>
> `std::distance()` 함수는 두 위치(Iterator) 사이의 거리를 정수로 계산하여 반환합니다.
{: .prompt-tip }

----------

## 시간복잡도

최솟값과 최댓값을 찾는 방법을 사용했을 때의 시간복잡도는 $O(N)$입니다.

왜냐하면, `N`개의 숫자를 처리하려면 `N`번의 반복을 통해 모든 숫자를 한 번씩 확인해야 하기 때문입니다. 이보더 다 빠르게 최솟값과 최댓값을 찾을 수 없습니다.

> **정렬을 사용하여 좌측 끝과 우측 끝을 구하면 되지 않을까요?**
>
> 좋은 생각입니다. 하지만, 정렬 알고리즘은 보통 $O(N \log N)$의 시간이 걸립니다. $O(N)$보다 느리기 때문에, 배보다 배꼽이 커지는 경우입니다. 아이디어는 좋았습니다.
{: .gh-alert.note }

----------

## 마무리

1. **기본 로직**
   
   변수를 두고 하나씩 확인하며 값을 갱신한다.
2.  **초기화 주의**
    
    `0`으로 초기화 하지 말고, 배열의 첫 번째 원소나 극한값을 사용합시다.
3.  **STL의 함수 이용**
    
    굳이 구현하는 건 귀찮으니 STL에서 제공하는 `std::min_element()`와 `std::max_element()`를 사용합시다.

----------

## 추천 문제

- [⚔️ 백준 10818번 - 최소, 최대](https://www.acmicpc.net/problem/10818 "백준 10818번 - 최소, 최대")
- [⚔️ 백준 20053번 - 최소, 최대 2](https://www.acmicpc.net/problem/20053 "백준 20053번 - 최소, 최대 2")
- [⚔️ 백준 2562번 - 최댓값](https://www.acmicpc.net/problem/2562 "백준 2562번 - 최댓값")

오늘 우리가 배운 내용을 토대로 쉽게 해결할 수 있는 문제로, 별도의 해설과 답안을 제공하지 않습니다.